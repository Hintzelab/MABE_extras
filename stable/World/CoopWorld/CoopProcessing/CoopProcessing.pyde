# This will visualize the data generated by CoopWorld (CoopWorldData.txt).

# The visualization shows 6 grids.
# 1) score (normalized by scoreMax)
# 2) genotype - on birth, organisms inherit an rgb color and mutate this
#                  If two colors in this grid are diffrent then there is
#                  genetic distance. If two colors are alike, they may or
#                  may not be related
# 3) action - Red - group hunt, green - solo hunt, blue - no action
#                   A mixed color indicates that the agent is using a mixed stratagy
# 4) rank - white = high, black = low, red = max
# 5) births - shows the number of births per agent
# 6) age - ages of agents

# at the bottom of the displace is:
#   update, play back step, color of pixle under cursor

# interface:
# left and right arrows speed up and slow down play back
# left click = pause
# right click = show box, will place a box on the location under the cursor and
#   a box in each grid at that location

# set this to point at the CoopWorldData.txt file
fileName = 'c:/Users/cliff/Desktop/testMABETEMP/CoopWorldData.txt'

# these values need to be set based on your settings

# values will be normalized to their max values, or appear red if above max
scoreMax = 4
ageMax = 25.0
offspringMax = 5
# for actionMax, max should be set to (subgroupSize * gamesPerSubgroup)
actionMax = 9 * 5

# parameters which affect display
frameSize = 400
centerSpace = 30



############################################################
##
##  do not edit below this line
##
############################################################
# global vars
fileHandle = open(fileName, 'r+')
renderStep = 1

windowSizeX = (frameSize * 3) + (centerSpace * 2)
windowSizeY = (frameSize * 2) + (centerSpace * 1) + 100

worldX = 20
worldY = 20
worldTime = -1
scoreGrid = []
rankGrid = []
actionGrid = []
ageGrid = []
offspringCountGrid = []
genotypeGrid = []
play = 1
showDot = 0

gridSize = 6
offset = 0

def mousePressed():
    global play
    global showDot
    if mouseButton == LEFT:
        if play == 1:
            #noLoop()
            play = 0
        elif play == 0:
            #loop()
            play = 1
    if mouseButton == RIGHT:
        if showDot == 1:
            showDot = 0
        elif showDot == 0:
            showDot = 1

def keyPressed():
    global renderStep
    global fileName;
    global fileHandle;
    global play
    
    if key == CODED:
        if (keyCode == RIGHT):
            renderStep = renderStep * 2
        if (keyCode == LEFT):
            renderStep = renderStep / 2;
            if (renderStep < 1):
                renderStep = 1;
    if str(key) in ' ':
        if play == 1:
            #noLoop()
            play = 0
        elif play == 0:
            #loop()
            play = 1

def loadNextLineFromFile():
    global fileHandle
    global fileName
    global currentIteration
    line = fileHandle.readline().strip()
    if line == 'EOF':
        print("at End of File, restarting...")
        currentIteration = 0
        #noLoop()
        fileHandle = open(fileName, 'r+')    
        line = fileHandle.readline().strip()
    return line

def readNextLineFromFile():
    global fileHandle
    global fileName
    line = loadNextLineFromFile()
    if line == 'EOF':
        print("at End of File")
        #noLoop()
        fileHandle = open(fileName, 'r+')

    while (line == ""):
        line = loadNextLineFromFile()
    splitLine = split(line,',')
    return splitLine

def skipNextLineFromFile():
    global fileHandle
    global fileName
    line = fileHandle.readline()
    if line == 'EOF':
        print("at End of File")
        #noLoop()
        fileHandle = open(fileName, 'r+')

    while (line == ""):
        line = loadNextLineFromFile()

def loadFloatGrid():
    global worldTime
    if worldTime%renderStep == 0:
        global worldX
        global worldY
        global windowSize
        global gridSize
        targetGrid = []
        splitLine = readNextLineFromFile()
        worldX = int(splitLine[0])
        worldY = int(splitLine[1])
        gridSize = (float(frameSize)) / (float(worldX))
        scoreGrid = []
        for y in range(worldY):
            splitLine = readNextLineFromFile()
            for x in range(worldX):
                targetGrid.append(splitLine[x])
        return (1,targetGrid)
    else:
        skipNextLineFromFile()
        for y in range(worldY):
            skipNextLineFromFile()
        return (0,0)      

def drawFloatGrid(dataGrid,rangeMax,xOffset,yOffset,maxVal = 1000000000):
    global gridSize
    global worldX
    global worldY
    
    for xx in range(worldX*worldY):
        if float(dataGrid[xx]) >= maxVal:
            fill(255,0,0)
        else:
            fill((float(dataGrid[xx]))*rangeMax)
        rect(int(xx % worldX) * gridSize + (((worldX*gridSize) + centerSpace)*xOffset),int(xx/worldY) * gridSize + (((worldY*gridSize) + centerSpace)*yOffset),gridSize,gridSize)

    
def loadColorGrid():
    global worldTime
    if worldTime%renderStep == 0:
        global worldX
        global worldY
        global windowSize
        global gridSize
        splitLine = readNextLineFromFile()
        worldX = int(splitLine[0])
        worldY = int(splitLine[1])
        gridSize = (float(frameSize)) / (float(worldX))
        targetGrid = []
        for y in range(worldY):
            splitLine = readNextLineFromFile()
            for x in range(worldX):
                colorList = (splitLine[x]).split(':')
                targetGrid.append(float(colorList[0]))
                targetGrid.append(float(colorList[1]))
                targetGrid.append(float(colorList[2]))
        return (1,targetGrid)
    else:
        skipNextLineFromFile()
        for y in range(worldY):
            skipNextLineFromFile()
        return (0,0)      

def drawColorGrid(dataGrid,rangeMax,xOffset,yOffset,maxVal = 1000000000):
    global gridSize
    global worldX
    global worldY
    for xx in range(worldX*worldY):
        fill((float(dataGrid[(3*xx)]))*rangeMax,(float(dataGrid[(3*xx)+1]))*rangeMax,(float(dataGrid[(3*xx)+2]))*rangeMax)
        rect(int(xx % worldX) * gridSize + (((worldX*gridSize) + centerSpace)*xOffset),int(xx/worldY) * gridSize + (((worldY*gridSize) + centerSpace)*yOffset),gridSize,gridSize)


def setup():
    global worldX
    global worldY
    global gridSize
    global windowSizeX
    global windowSizeY
    background(0)
    stroke(0,0,0)
    frameRate(1000)
    size(windowSizeX, windowSizeY)
    smooth(30)
  
def draw():
    global scoreGrid
    global rankGrid
    global offspringCountGrid
    global actionGrid
    global ageGrid
    global genotypeGrid
    global worldTime
    global worldX
    global worldY
    global fps
    global gridSize
    global windowSize
    global fileName
    global timeChecker
    
    global scoreMax
    global ageMax
    global offspringMax
    global actionMax
    
    global currentIteration

    if play == 1:
        splitLine = readNextLineFromFile()
        if (splitLine[0] == "**actionMap**"):
            check,returnGrid = loadColorGrid()
            if check:
                actionGrid = returnGrid
        if (splitLine[0] == "**ageMap**"):
            check,returnGrid = loadFloatGrid()
            if check:
                ageGrid = returnGrid
        if (splitLine[0] == "**ScoreMap**"):
            check,returnGrid = loadFloatGrid()
            if check:
                scoreGrid = returnGrid
        if (splitLine[0] == "**rankMap**"):
            check,returnGrid = loadFloatGrid()
            if check:
                rankGrid = returnGrid
        if (splitLine[0] == "**offspringCountMap**"):
            check,returnGrid = loadFloatGrid()
            if check:
                offspringCountGrid = returnGrid
        if (splitLine[0] == "**ColorMap**"):
            #loadColorGrid()
            check,returnGrid = loadColorGrid()
            if check:
                genotypeGrid = returnGrid
        if (splitLine[0][0] == "u"):
            worldTime = int(splitLine[1])
    if (play == 0) or (splitLine[0][0] == "u"):
        if (play == 0) or (worldTime%renderStep == 0) :
            background(0);
            fill(0)
            stroke(0)
            strokeWeight(1)
            drawFloatGrid(scoreGrid,255.0/scoreMax,0,0,scoreMax)
            drawFloatGrid(rankGrid,255.0/float(worldX*worldY),0,1,worldX*worldY)
            drawFloatGrid(offspringCountGrid,255.0/offspringMax,1,1,offspringMax)
            drawColorGrid(actionGrid,255.0/actionMax,2,0,3)
            drawFloatGrid(ageGrid,255.0/ageMax,2,1)
            drawColorGrid(genotypeGrid,255,1,0)
            fill(0)
            stroke(0)
            strokeWeight(0)
            rect(0,windowSizeY-100,windowSizeX,100)
            
            fill(255,255,255)
            textSize(20)
            text("                      SCORE                                                        GENOTYPE                                                       ACTION", 20, int(frameSize)+25)
            text("                      RANK                                                          OFFSPRING                                                          AGE", 20, int(windowSizeY) - 75)
            text(str(worldTime) + "   PLAY BACK STEP: " + str(renderStep), 20, int(windowSizeY)-30)
            text("                                                        " + str(round(red(get().pixels[mouseX + mouseY * width])/255,2))+"   "+str(round(green(get().pixels[mouseX + mouseY * width])/255,2))+"   "+str(round(blue(get().pixels[mouseX + mouseY * width])/255,2)), 20, int(windowSizeY)-30)
            #noLoop()

            if showDot:
                fill(0,0,0,0)
                stroke(255,255,255)
                strokeWeight(2)
                for ox in [-2,-1,0,1,2]:
                    for oy in [-2,-1,0,1,2]:
                        xCenterCorrection = int((float(mouseX)/float(worldX*gridSize+centerSpace))*float(centerSpace))/centerSpace
                        yCenterCorrection = int((float(mouseY)/float(worldY*gridSize+centerSpace))*float(centerSpace))/centerSpace
                        
                        realXpos = mouseX - (centerSpace * xCenterCorrection)
                        realYpos = mouseY - (centerSpace * yCenterCorrection)
                        xpos = (realXpos - (realXpos%gridSize)) + (centerSpace * xCenterCorrection)
                        ypos = (realYpos - (realYpos%gridSize)) + (centerSpace * yCenterCorrection)

                        xpos = xpos+(ox * (worldX*gridSize+centerSpace))
                        ypos = ypos+(oy * (worldY*gridSize+centerSpace))

                        
                        rect(xpos,ypos,gridSize,gridSize)
                        
                        #rect(int(xx % worldX) * gridSize + (((worldX*gridSize) + centerSpace)*xOffset),int(xx/worldY) * gridSize + (((worldY*gridSize) + centerSpace)*yOffset),gridSize,gridSize)

                fill(0)
                stroke(0)
                strokeWeight(0)
    
